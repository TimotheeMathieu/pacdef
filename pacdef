#!/usr/bin/python

import argparse
import configparser
import subprocess
import sys
from pathlib import Path
from typing import List
from os import environ
from enum import Enum


AUR_HELPER: Path
CONFIG_FILE: Path
GROUPS_PATH: Path


def main():
    parse_config()
    args = parse_args()

    if args.action == Actions.clean.value:
        remove_unmanaged_packages()
    elif args.action == Actions.groups.value:
        show_groups()
    elif args.action == Actions.import_.value:
        import_groups(args)
    elif args.action == Actions.remove.value:
        remove_group(args)
    elif args.action == Actions.show_group.value:
        show_group(args)
    elif args.action == Actions.sync.value:
        install_packages_from_groups()
    elif args.action == Actions.unmanaged.value:
        show_unmanaged_packages()
    else:
        print('Did not understand what you want me to do')
        sys.exit(1)


def aur_helper_execute(command: List[str]) -> None:
    try:
        subprocess.call([str(AUR_HELPER)] + command)
    except FileNotFoundError:
        print(f'Could not start the AUR helper "{AUR_HELPER}".')
        sys.exit(1)


def get_packages_from_pacdef() -> List[str]:
    packages = []
    try:
        for f in GROUPS_PATH.iterdir():
            with open(f) as fd:
                lines = fd.readlines()
            for line in lines:
                package_name = line.split('#')[0].strip()
                if len(package_name) > 0:
                    packages.append(package_name)
    except FileNotFoundError:
        pass
    return packages


def parse_config() -> None:
    global AUR_HELPER, CONFIG_FILE, GROUPS_PATH

    config_base = get_xdg_config_home()

    pacdef_path = config_base.joinpath('pacdef')
    CONFIG_FILE = pacdef_path.joinpath('pacdef.conf')
    GROUPS_PATH = pacdef_path.joinpath('groups')

    if not dir_exists(pacdef_path):
        pacdef_path.mkdir(parents=True)

    if not file_exists(CONFIG_FILE):
        CONFIG_FILE.touch()

    config = configparser.ConfigParser()
    config.read(CONFIG_FILE)

    AUR_HELPER = get_aur_helper(config)


def get_xdg_config_home():
    try:
        config_base = Path(environ['XDG_CONFIG_HOME'])
    except KeyError:
        home = Path.home()
        config_base = home.joinpath('.config')
    return config_base


def get_aur_helper(config: configparser.ConfigParser) -> Path:
    try:
        aur_helper = Path(config['misc']['aur_helper'])
    except (KeyError, ValueError):
        aur_helper = Path('/usr/bin/paru')
    return aur_helper


def show_unmanaged_packages() -> None:
    pacdef_packages = get_packages_from_pacdef()
    installed_packages_explicit = subprocess.check_output(['pacman', '-Qqe']).decode('utf-8')
    installed_packages_explicit = installed_packages_explicit.split('\n')[:-1]  # last entry is zero-length
    unmanaged_packages = [p for p in installed_packages_explicit if p not in pacdef_packages]
    for p in unmanaged_packages:
        print(p)


def install_packages_from_groups() -> None:
    packages = get_packages_from_pacdef()
    installed_packages_all = subprocess.check_output(['pacman', '-Qq']).decode('utf-8')
    installed_packages = installed_packages_all.split('\n')[:-1]  # last entry is zero-length
    to_sync = [p for p in packages if p not in installed_packages]
    if len(to_sync) == 0:
        print('nothing to do')
    else:
        aur_helper_execute(['--sync', '--refresh', '--needed'] + to_sync)


def show_group(args: argparse.Namespace) -> None:
    groups = args.group
    if len(groups) == 0:
        print('which group do you want to show?')
        sys.exit(1)
    files = list(GROUPS_PATH.iterdir())
    files.sort()
    for f in files:
        if f in groups:
            with open(GROUPS_PATH.joinpath(f)) as fd:
                print(fd.read().strip())  # remove final newline


def remove_group(args: argparse.Namespace) -> None:
    # TODO make atomic
    groups = args.group
    if len(groups) == 0:
        print('nothing to remove')
    for g in groups:
        actual_file = GROUPS_PATH.joinpath(g)
        if actual_file.is_symlink() or file_exists(actual_file):
            subprocess.call(['rm', actual_file])
        else:
            print(f'Did not find the group {g}')
            sys.exit(1)


def import_groups(args: argparse.Namespace) -> None:
    files = args.file
    # check if all file-arguments exist before we do anything (be atomic)
    for f in files:
        path = Path(f)
        if not file_exists(path):
            print(f'Cannot import {f}, does not exist')
            sys.exit(1)
    for f in files:
        path = Path(f)
        link_target = GROUPS_PATH.joinpath(f)
        if file_exists(link_target):
            print(f'{f} already exists, skipping')
        else:
            link_target.symlink_to(path)


def show_groups() -> None:
    files = list(GROUPS_PATH.iterdir())
    files.sort()
    for f in files:
        print(f)


def remove_unmanaged_packages() -> None:
    pacdef_packages = get_packages_from_pacdef()
    installed_packages_explicit = subprocess.check_output(['pacman', '-Qqe']).decode('utf-8')
    installed_packages_explicit = installed_packages_explicit.split('\n')[:-1]  # last entry is zero-length
    packages_to_remove = [p for p in installed_packages_explicit if p not in pacdef_packages]
    if len(packages_to_remove) == 0:
        print('nothing to do')
        sys.exit(0)
    print('Would remove the following packages and their dependencies:')
    for p in packages_to_remove:
        print(p)
    while True:
        user_input = input('Continue? [y/N] ')
        if len(user_input) > 1:
            pass
        elif user_input.lower() == 'y':
            break
        elif user_input.lower() in ['', 'n']:
            sys.exit(0)
    aur_helper_execute(['--remove', '--recursive'] + packages_to_remove)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description='a declarative manager of Arch packages')
    subparsers = parser.add_subparsers(dest='action', required=True, metavar='<action>')
    subparsers.add_parser(Actions.clean.value, help='uninstall packages not managed by pacdef')
    subparsers.add_parser(Actions.groups.value, help='show names of imported groups')
    parser_import = subparsers.add_parser(Actions.import_.value, help='import a new group file')
    parser_import.add_argument('file', nargs='+', help='a group file')
    parser_remove = subparsers.add_parser(Actions.remove.value, help='remove previously imported group')
    parser_remove.add_argument('group', nargs='+', help='a previously imported group')
    parser_show_group = subparsers.add_parser(Actions.show_group.value, help='show packages under an imported group')
    parser_show_group.add_argument('group', nargs='+', help='a previously imported group')
    subparsers.add_parser(Actions.sync.value, help='install packages from all imported groups')
    subparsers.add_parser(Actions.unmanaged.value, help='show explicitly installed packages not managed by pacdef')
    args = parser.parse_args()
    return args


def dir_exists(path: Path) -> bool:
    return path.exists() and path.is_dir()


def file_exists(path: Path) -> bool:
    return path.exists() and path.is_file()


class Actions(Enum):
    clean = 'clean'
    groups = 'groups'
    import_ = 'import'
    remove = 'remove'
    show_group = 'show-group'
    sync = 'sync'
    unmanaged = 'unmanaged'


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(130)
